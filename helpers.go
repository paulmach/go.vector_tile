// Package vector_tile provides the go code needed to read and write
// Mapbox vector tiles (https://github.com/mapbox/vector-tile-spec).
// Most of the code is autogenerated, but there are a few helpers
// the make encoded and decoded the tiles a little easier.
package vector_tile

//go:generate protoc --go_out=. vector_tile.proto

import (
	"bytes"
	"io/ioutil"

	"compress/gzip"

	"github.com/golang/protobuf/proto"
)

// Encode protobuf encodes the tile into a byte buffer.
func Encode(tile *Tile) ([]byte, error) {
	return proto.Marshal(tile)
}

// EncodeGzipped gzips the data after encoding the tile via protocol buffers.
func EncodeGzipped(tile *Tile) ([]byte, error) {
	data, err := Encode(tile)
	if err != nil {
		return nil, err
	}

	buf := bytes.NewBuffer(nil)
	gzWriter := gzip.NewWriter(buf)
	defer gzWriter.Close()

	_, err = gzWriter.Write(data)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

// Decode has the protobuf library decode the data into a tile.
func Decode(data []byte) (*Tile, error) {
	tile := &Tile{}
	err := proto.Unmarshal(data, tile)

	return tile, err
}

// DecodeGzipped first ungzips the data before having the
// protobuf library decode the data into a tile.
func DecodeGzipped(data []byte) (*Tile, error) {
	gzReader, err := gzip.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, err
	}
	defer gzReader.Close()

	ungzipped, err := ioutil.ReadAll(gzReader)
	if err != nil {
		return nil, err
	}

	return Decode(ungzipped)
}
